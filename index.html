<!DOCTYPE html>
<html lang="en">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="generator" content="Laika 0.18.1 + Helium Theme" />
    <title>cats-parse</title>
    
      <meta name="author" content="P. Oscar Boykin"/>
    
    
      <meta name="description" content="docs"/>
    
    
      <link rel="icon" sizes="32x32" type="image/png" href="https://typelevel.org/img/favicon.png"/>
    
    
      <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Lato:400,700">
    
      <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/tonsky/FiraCode@1.207/distr/fira_code.css">
    
    <link rel="stylesheet" type="text/css" href="helium/icofont.min.css" />
    <link rel="stylesheet" type="text/css" href="helium/laika-helium.css" />
    <link rel="stylesheet" type="text/css" href="site/styles.css" />
    <script src="helium/laika-helium.js"></script>
    
    
    <script> /* for avoiding page load transitions */ </script>
  </head>

  <body>

    <header id="top-bar">

      <div class="row">
        <a id="nav-icon">
          <i class="icofont-laika" title="Navigation">&#xefa2;</i>
        </a>
        
      </div>

      <a class="image-link" href="https://typelevel.org"><img src="https://typelevel.org/img/logo.svg"></a>

      <span class="row links"><a class="icon-link svg-link" href="https://github.com/typelevel/cats-parse"><span title="Source Code"><svg class="svg-icon" width="100%" height="100%" viewBox="0 0 100 100" version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" xml:space="preserve" xmlns:serif="http://www.serif.com/" style="fill-rule:evenodd;clip-rule:evenodd;stroke-linejoin:round;stroke-miterlimit:2;">
  <g class="svg-shape">
    <path d="M49.995,1c-27.609,-0 -49.995,22.386 -49.995,50.002c-0,22.09 14.325,40.83 34.194,47.444c2.501,0.458 3.413,-1.086 3.413,-2.412c0,-1.185 -0.043,-4.331 -0.067,-8.503c-13.908,3.021 -16.843,-6.704 -16.843,-6.704c-2.274,-5.773 -5.552,-7.311 -5.552,-7.311c-4.54,-3.103 0.344,-3.042 0.344,-3.042c5.018,0.356 7.658,5.154 7.658,5.154c4.46,7.64 11.704,5.433 14.552,4.156c0.454,-3.232 1.744,-5.436 3.174,-6.685c-11.102,-1.262 -22.775,-5.553 -22.775,-24.713c-0,-5.457 1.949,-9.92 5.147,-13.416c-0.516,-1.265 -2.231,-6.348 0.488,-13.233c0,0 4.199,-1.344 13.751,5.126c3.988,-1.108 8.266,-1.663 12.518,-1.682c4.245,0.019 8.523,0.574 12.517,1.682c9.546,-6.47 13.736,-5.126 13.736,-5.126c2.728,6.885 1.013,11.968 0.497,13.233c3.204,3.496 5.141,7.959 5.141,13.416c0,19.209 -11.691,23.436 -22.83,24.673c1.795,1.544 3.394,4.595 3.394,9.26c0,6.682 -0.061,12.076 -0.061,13.715c0,1.338 0.899,2.894 3.438,2.406c19.853,-6.627 34.166,-25.354 34.166,-47.438c-0,-27.616 -22.389,-50.002 -50.005,-50.002"/>
  </g>
</svg></span></a><a class="icon-link" href="https://discord.gg/XF3CXcMzqD"><i class="icofont-laika" title="Chat">&#xeed5;</i></a><a class="icon-link" href="https://twitter.com/typelevel"><i class="icofont-laika" title="Twitter">&#xed7a;</i></a></span>

    </header>

    <nav id="sidebar">

      <div class="row">
        <a class="icon-link svg-link" href="https://github.com/typelevel/cats-parse"><span title="Source Code"><svg class="svg-icon" width="100%" height="100%" viewBox="0 0 100 100" version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" xml:space="preserve" xmlns:serif="http://www.serif.com/" style="fill-rule:evenodd;clip-rule:evenodd;stroke-linejoin:round;stroke-miterlimit:2;">
  <g class="svg-shape">
    <path d="M49.995,1c-27.609,-0 -49.995,22.386 -49.995,50.002c-0,22.09 14.325,40.83 34.194,47.444c2.501,0.458 3.413,-1.086 3.413,-2.412c0,-1.185 -0.043,-4.331 -0.067,-8.503c-13.908,3.021 -16.843,-6.704 -16.843,-6.704c-2.274,-5.773 -5.552,-7.311 -5.552,-7.311c-4.54,-3.103 0.344,-3.042 0.344,-3.042c5.018,0.356 7.658,5.154 7.658,5.154c4.46,7.64 11.704,5.433 14.552,4.156c0.454,-3.232 1.744,-5.436 3.174,-6.685c-11.102,-1.262 -22.775,-5.553 -22.775,-24.713c-0,-5.457 1.949,-9.92 5.147,-13.416c-0.516,-1.265 -2.231,-6.348 0.488,-13.233c0,0 4.199,-1.344 13.751,5.126c3.988,-1.108 8.266,-1.663 12.518,-1.682c4.245,0.019 8.523,0.574 12.517,1.682c9.546,-6.47 13.736,-5.126 13.736,-5.126c2.728,6.885 1.013,11.968 0.497,13.233c3.204,3.496 5.141,7.959 5.141,13.416c0,19.209 -11.691,23.436 -22.83,24.673c1.795,1.544 3.394,4.595 3.394,9.26c0,6.682 -0.061,12.076 -0.061,13.715c0,1.338 0.899,2.894 3.438,2.406c19.853,-6.627 34.166,-25.354 34.166,-47.438c-0,-27.616 -22.389,-50.002 -50.005,-50.002"/>
  </g>
</svg></span></a><a class="icon-link" href="https://discord.gg/XF3CXcMzqD"><i class="icofont-laika" title="Chat">&#xeed5;</i></a><a class="icon-link" href="https://twitter.com/typelevel"><i class="icofont-laika" title="Twitter">&#xed7a;</i></a>
      </div>

      <ul class="nav-list">
        <li class="level1 active"><a href="#">cats-parse</a></li>
      </ul>

      <ul class="nav-list">
        <li class="level1 nav-header">Related Projects</li>
        
          <li class="level2"><a href="https://typelevel.org/cats/">cats</a></li>
        
      </ul>

    </nav>

    <div id="container">

      <nav id="page-nav">
        <p class="header"><a href="#">cats-parse</a></p>

        <ul class="nav-list">
          <li class="level1"><a href="#tutorial">Tutorial</a></li>
          <li class="level2"><a href="#simple-parser">Simple parser</a></li>
          <li class="level2"><a href="#mapping-output">Mapping output</a></li>
          <li class="level2"><a href="#combining-parsers">Combining parsers</a></li>
          <li class="level2"><a href="#repeating-parsers">Repeating parsers</a></li>
          <li class="level2"><a href="#parsers-with-empty-output">Parsers with empty output</a></li>
          <li class="level2"><a href="#error-handling">Error handling</a></li>
          <li class="level1"><a href="#json-parser-example">JSON parser example</a></li>
          <li class="level1"><a href="#performance">Performance</a></li>
          <li class="level1"><a href="#migrating-from-fastparse">Migrating from Fastparse</a></li>
          <li class="level1"><a href="#getting-and-giving-help">Getting and Giving Help</a></li>
        </ul>

        <p class="footer"></p>
      </nav>

      <main class="content">

        <h1 id="cats-parse" class="title">cats-parse</h1>
        <p><a href="https://github.com/typelevel/cats-parse/actions?query=workflow%3A%22Continuous+Integration%22"><img src="https://github.com/typelevel/cats-parse/workflows/Continuous%20Integration/badge.svg" alt="Continuous Integration"></a><a href="https://codecov.io/gh/typelevel/cats-parse"><img src="https://codecov.io/gh/typelevel/cats-parse/branch/main/graph/badge.svg" alt="codecov"></a></p>
        <p>A parsing library for the cats ecosystem.</p>
        <p>To use in sbt add, the following to your <code>libraryDependencies</code>:</p>
        <pre class="keep-together pdf epub"><code class="nohighlight"><span class="comment">// use this snippet for the JVM
</span><span class="identifier">libraryDependencies</span><span> += </span><span class="string-literal">&quot;org.typelevel&quot;</span><span> %% </span><span class="string-literal">&quot;cats-parse&quot;</span><span> % </span><span class="string-literal">&quot;0.3.7&quot;</span><span>

</span><span class="comment">// use this snippet for JS, or cross-building
</span><span class="identifier">libraryDependencies</span><span> += </span><span class="string-literal">&quot;org.typelevel&quot;</span><span> %%% </span><span class="string-literal">&quot;cats-parse&quot;</span><span> % </span><span class="string-literal">&quot;0.3.7&quot;</span></code></pre>
        <p>The <a href="https://javadoc.io/doc/org.typelevel/cats-parse_2.13/0.3.7/cats/parse/index.html">API docs</a> are published.</p>
        <p>Why another parsing library? See this <a href="https://posco.medium.com/designing-a-parsing-library-in-scala-d5076de52536">blog post detailing the
        design</a>. To reiterate,
        this library has a few goals:</p>
        <ol class="arabic">
          <li>Compatibility: should work on all scala platforms and recent versions. Currently it supports JVM, JS on versions 2.11, 2.12, 2.13, and 3. The core library should have minimal dependencies. Currently this library only depends on cats.</li>
          <li>Excellent performance: should be as fast or faster than any parser combinator that has comparable scala version support.</li>
          <li>Cats friendliness: method names match cats style, and out of the box support for cats typeclasses.</li>
          <li>Precise errors: following the <a href="https://hackage.haskell.org/package/trifecta">Haskell Trifecta parsing library</a>, backtracking is opt-in vs opt-out. This design tends to make it easier to write parsers that point correctly to failure points.</li>
          <li>Safety: by separating Parser0, a parser that may consume no input, from Parser, a parser must consume at least one character on success. Most combinators and methods can be made safer to use and less prone to runtime errors.</li>
          <li>Stability: we are very reluctant to break compatibility between versions. We want to put a minimal tax on users to stay on the latest versions.</li>
        </ol>
        
        <h1 id="tutorial" class="section">Tutorial<a class="anchor-link right" href="#tutorial"><i class="icofont-laika">&#xef71;</i></a></h1>
        
        <h2 id="simple-parser" class="section">Simple parser<a class="anchor-link right" href="#simple-parser"><i class="icofont-laika">&#xef71;</i></a></h2>
        <p>The library provides a set of simple parsers which might be combined to create any parsing logic. The simplest parser is <code>Parser.anyChar</code> which is successful where there is one char at the input. It has type <code>Parser[Char]</code> which means it returns one parsed char.</p>
        <p>To provide any input to parser one need to use <code>parse</code> method.</p>
        <pre><code class="nohighlight"><span class="keyword">import</span><span> </span><span class="identifier">cats</span><span>.</span><span class="identifier">parse</span><span>.</span><span class="type-name">Parser</span><span>

</span><span class="keyword">val</span><span> </span><span class="identifier">p</span><span>: </span><span class="type-name">Parser</span><span>[</span><span class="type-name">Char</span><span>] = </span><span class="type-name">Parser</span><span>.</span><span class="identifier">anyChar</span><span>
</span><span class="comment">// p: Parser[Char] = AnyChar
</span><span>
</span><span class="identifier">p</span><span>.</span><span class="identifier">parse</span><span>(</span><span class="string-literal">&quot;t&quot;</span><span>)
</span><span class="comment">// res1: Either[Parser.Error, (String, Char)] = Right(value = (&quot;&quot;, &#39;t&#39;))
// res0: Either[Error, Tuple2[String, Char]] = Right((,t))
</span><span class="identifier">p</span><span>.</span><span class="identifier">parse</span><span>(</span><span class="string-literal">&quot;&quot;</span><span>)
</span><span class="comment">// res2: Either[Parser.Error, (String, Char)] = Left(
//   value = Error(
//      = 0,
//      = NonEmptyList(
//       head = InRange(offset = 0, lower = &#39;\u0000&#39;, upper = &#39;\uffff&#39;),
//       tail = List()
//     )
//   )
// )
// res1: Either[Error, Tuple2[String, Char]] = Left(Error(0,NonEmptyList(InRange(0,,))))
</span><span class="identifier">p</span><span>.</span><span class="identifier">parse</span><span>(</span><span class="string-literal">&quot;two&quot;</span><span>)
</span><span class="comment">// res3: Either[Parser.Error, (String, Char)] = Right(value = (&quot;wo&quot;, &#39;t&#39;))</span></code></pre>
        <p>Notice the return type. <code>Tuple2[String, Char]</code> contains the rest of the input string and one parsed char if parsing was successful. It returns <code>Left</code> with error message if there was some parsing error.</p>
        
        <h2 id="mapping-output" class="section">Mapping output<a class="anchor-link right" href="#mapping-output"><i class="icofont-laika">&#xef71;</i></a></h2>
        <p>The output of the parser might be processed with <code>map</code> method:</p>
        <pre class="keep-together pdf epub"><code class="nohighlight"><span class="keyword">import</span><span> </span><span class="identifier">cats</span><span>.</span><span class="identifier">parse</span><span>.</span><span class="type-name">Parser</span><span>

</span><span class="keyword">case</span><span> </span><span class="keyword">class</span><span> </span><span class="type-name">CharWrapper</span><span>(</span><span class="identifier">value</span><span>: </span><span class="type-name">Char</span><span>)

</span><span class="keyword">val</span><span> </span><span class="identifier">p</span><span>: </span><span class="type-name">Parser</span><span>[</span><span class="type-name">CharWrapper</span><span>] = </span><span class="type-name">Parser</span><span>.</span><span class="identifier">anyChar</span><span>.</span><span class="identifier">map</span><span>(</span><span class="identifier">char</span><span> =&gt; </span><span class="type-name">CharWrapper</span><span>(</span><span class="identifier">char</span><span>))
</span><span class="comment">// p: Parser[CharWrapper] = Map(parser = AnyChar, fn = &lt;function1&gt;)
</span><span>
</span><span class="identifier">p</span><span>.</span><span class="identifier">parse</span><span>(</span><span class="string-literal">&quot;t&quot;</span><span>)
</span><span class="comment">// res5: Either[Parser.Error, (String, CharWrapper)] = Right(
//   value = (&quot;&quot;, CharWrapper(value = &#39;t&#39;))
// )</span></code></pre>
        <p>There are built-in methods for mapping the output to types <code>String</code> or <code>Unit</code>:</p>
        <pre><code class="nohighlight"><span class="keyword">import</span><span> </span><span class="identifier">cats</span><span>.</span><span class="identifier">parse</span><span>.</span><span class="type-name">Rfc5234</span><span>.</span><span class="identifier">digit</span><span>
</span><span class="keyword">import</span><span> </span><span class="identifier">cats</span><span>.</span><span class="identifier">parse</span><span>.</span><span class="type-name">Parser</span><span>

</span><span class="comment">/* String */</span><span>

</span><span class="keyword">val</span><span> </span><span class="identifier">p2</span><span>: </span><span class="type-name">Parser</span><span>[</span><span class="type-name">String</span><span>] = </span><span class="identifier">digit</span><span>.</span><span class="identifier">map</span><span>((</span><span class="identifier">c</span><span>: </span><span class="type-name">Char</span><span>) =&gt; </span><span class="identifier">c</span><span>.</span><span class="identifier">toString</span><span>)
</span><span class="comment">// p2: Parser[String] = Map(
//   parser = CharIn(
//     min = 48,
//     bitSet = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9},
//     ranges = NonEmptyList(head = (&#39;0&#39;, &#39;9&#39;), tail = List())
//   ),
//   fn = &lt;function1&gt;
// )
// is analog to
</span><span class="keyword">val</span><span> </span><span class="identifier">p3</span><span>: </span><span class="type-name">Parser</span><span>[</span><span class="type-name">String</span><span>] = </span><span class="identifier">digit</span><span>.</span><span class="identifier">string</span><span>
</span><span class="comment">// p3: Parser[String] = StringP(
//   parser = CharIn(
//     min = 48,
//     bitSet = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9},
//     ranges = NonEmptyList(head = (&#39;0&#39;, &#39;9&#39;), tail = List())
//   )
// )
</span><span>
</span><span class="identifier">p3</span><span>.</span><span class="identifier">parse</span><span>(</span><span class="string-literal">&quot;1&quot;</span><span>)
</span><span class="comment">// res7: Either[Parser.Error, (String, String)] = Right(value = (&quot;&quot;, &quot;1&quot;))
// res0: Either[Error, Tuple2[String, String]] = Right((,1))
</span><span>
</span><span class="comment">/* Unit */</span><span>

</span><span class="keyword">val</span><span> </span><span class="identifier">p4</span><span>: </span><span class="type-name">Parser</span><span>[</span><span class="type-name">Unit</span><span>] = </span><span class="identifier">digit</span><span>.</span><span class="identifier">map</span><span>(</span><span class="identifier">_</span><span> =&gt; ())
</span><span class="comment">// p4: Parser[Unit] = Map(
//   parser = CharIn(
//     min = 48,
//     bitSet = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9},
//     ranges = NonEmptyList(head = (&#39;0&#39;, &#39;9&#39;), tail = List())
//   ),
//   fn = &lt;function1&gt;
// )
// is analog to
</span><span class="keyword">val</span><span> </span><span class="identifier">p5</span><span>: </span><span class="type-name">Parser</span><span>[</span><span class="type-name">Unit</span><span>] = </span><span class="identifier">digit</span><span>.</span><span class="identifier">void</span><span>
</span><span class="comment">// p5: Parser[Unit] = Void(
//   parser = CharIn(
//     min = 48,
//     bitSet = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9},
//     ranges = NonEmptyList(head = (&#39;0&#39;, &#39;9&#39;), tail = List())
//   )
// )
</span><span>
</span><span class="identifier">p5</span><span>.</span><span class="identifier">parse</span><span>(</span><span class="string-literal">&quot;1&quot;</span><span>)
</span><span class="comment">// res8: Either[Parser.Error, (String, Unit)] = Right(value = (&quot;&quot;, ()))</span></code></pre>
        
        <h2 id="combining-parsers" class="section">Combining parsers<a class="anchor-link right" href="#combining-parsers"><i class="icofont-laika">&#xef71;</i></a></h2>
        <p>The parsers might be combined through operators:</p>
        <ul>
          <li><code>~</code> - product. Allows continuing parsing if the left side was successful;</li>
          <li><code>&lt;*</code>, <code>*&gt;</code> - productL and productR. Works just like product but drop part of result;</li>
          <li><code>surroundedBy</code> - identical to <code>border *&gt; parsingResult &lt;* border</code>;</li>
          <li><code>between</code> - identical to <code>border1 *&gt; parsingResult &lt;* border2</code>;</li>
          <li><code>|</code>, <code>orElse</code>. Parser will be successful if any of sides is successful.</li>
        </ul>
        <p>For this example we&#39;ll be using <code>cats.parse.Rfc5234</code> package which contains such parsers as <code>alpha</code> (Latin alphabet) and <code>sp</code> (whitespace).</p>
        <pre><code class="nohighlight"><span class="keyword">import</span><span> </span><span class="identifier">cats</span><span>.</span><span class="identifier">parse</span><span>.</span><span class="type-name">Rfc5234</span><span>.{</span><span class="identifier">sp</span><span>, </span><span class="identifier">alpha</span><span>, </span><span class="identifier">digit</span><span>}
</span><span class="keyword">import</span><span> </span><span class="identifier">cats</span><span>.</span><span class="identifier">parse</span><span>.</span><span class="type-name">Parser</span><span>

</span><span class="comment">/* Product */</span><span>

</span><span class="comment">// the sp parser won&#39;t return the whitespace, it just returns Unit if it successful
</span><span class="keyword">val</span><span> </span><span class="identifier">p1</span><span>: </span><span class="type-name">Parser</span><span>[(</span><span class="type-name">Char</span><span>, </span><span class="type-name">Unit</span><span>)] = </span><span class="identifier">alpha</span><span> ~ </span><span class="identifier">sp</span><span>
</span><span class="comment">// p1: Parser[(Char, Unit)] = Prod(
//   first = CharIn(
//     min = 65,
//     bitSet = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57},
//     ranges = NonEmptyList(head = (&#39;A&#39;, &#39;Z&#39;), tail = List((&#39;a&#39;, &#39;z&#39;)))
//   ),
//   second = Void(
//     parser = CharIn(
//       min = 32,
//       bitSet = {0},
//       ranges = NonEmptyList(head = (&#39; &#39;, &#39; &#39;), tail = List())
//     )
//   )
// )
</span><span>
</span><span class="identifier">p1</span><span>.</span><span class="identifier">parse</span><span>(</span><span class="string-literal">&quot;t&quot;</span><span>)
</span><span class="comment">// res10: Either[Parser.Error, (String, (Char, Unit))] = Left(
//   value = Error(
//      = 1,
//      = NonEmptyList(
//       head = InRange(offset = 1, lower = &#39; &#39;, upper = &#39; &#39;),
//       tail = List()
//     )
//   )
// )
// res0: Either[Error, Tuple2[String, Tuple2[Char, Unit]]] = Left(Error(1,NonEmptyList(InRange(1, , ))))
</span><span class="identifier">p1</span><span>.</span><span class="identifier">parse</span><span>(</span><span class="string-literal">&quot;t &quot;</span><span>)
</span><span class="comment">// res11: Either[Parser.Error, (String, (Char, Unit))] = Right(
//   value = (&quot;&quot;, (&#39;t&#39;, ()))
// )
// res1: Either[Error, Tuple2[String, Tuple2[Char, Unit]]] = Right((,(t,())))
</span><span>
</span><span class="comment">/* productL, productR */</span><span>

</span><span class="comment">// The type is just Char because we dropping the space
// to drop the alphabet change the arrow side: alpha *&gt; sp
</span><span class="keyword">val</span><span> </span><span class="identifier">p2</span><span>: </span><span class="type-name">Parser</span><span>[</span><span class="type-name">Char</span><span>] = </span><span class="identifier">alpha</span><span> &lt;* </span><span class="identifier">sp</span><span>
</span><span class="comment">// p2: Parser[Char] = Map(
//   parser = Prod(
//     first = CharIn(
//       min = 65,
//       bitSet = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57},
//       ranges = NonEmptyList(head = (&#39;A&#39;, &#39;Z&#39;), tail = List((&#39;a&#39;, &#39;z&#39;)))
//     ),
//     second = Void(
//       parser = CharIn(
//         min = 32,
//         bitSet = {0},
//         ranges = NonEmptyList(head = (&#39; &#39;, &#39; &#39;), tail = List())
//       )
//     )
//   ),
//   fn = cats.parse.Parser$$Lambda$13136/251357779@48f7dc64
// )
</span><span>
</span><span class="comment">// still error since we need the space even if we drop it
</span><span class="identifier">p2</span><span>.</span><span class="identifier">parse</span><span>(</span><span class="string-literal">&quot;t&quot;</span><span>)
</span><span class="comment">// res12: Either[Parser.Error, (String, Char)] = Left(
//   value = Error(
//      = 1,
//      = NonEmptyList(
//       head = InRange(offset = 1, lower = &#39; &#39;, upper = &#39; &#39;),
//       tail = List()
//     )
//   )
// )
// res2: Either[Error, Tuple2[String, Char]] = Left(Error(1,NonEmptyList(InRange(1, , ))))
</span><span class="identifier">p2</span><span>.</span><span class="identifier">parse</span><span>(</span><span class="string-literal">&quot;t &quot;</span><span>)
</span><span class="comment">// res13: Either[Parser.Error, (String, Char)] = Right(value = (&quot;&quot;, &#39;t&#39;))
// res3: Either[Error, Tuple2[String, Char]] = Right((,t))
</span><span>
</span><span class="comment">/* surroundedBy */</span><span>

</span><span class="keyword">val</span><span> </span><span class="identifier">p4</span><span>: </span><span class="type-name">Parser</span><span>[</span><span class="type-name">Char</span><span>] = </span><span class="identifier">sp</span><span> *&gt; </span><span class="identifier">alpha</span><span> &lt;* </span><span class="identifier">sp</span><span>
</span><span class="comment">// p4: Parser[Char] = Map(
//   parser = Prod(
//     first = Map(
//       parser = Prod(
//         first = Void(
//           parser = CharIn(
//             min = 32,
//             bitSet = {0},
//             ranges = NonEmptyList(head = (&#39; &#39;, &#39; &#39;), tail = List())
//           )
//         ),
//         second = CharIn(
//           min = 65,
//           bitSet = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57},
//           ranges = NonEmptyList(head = (&#39;A&#39;, &#39;Z&#39;), tail = List((&#39;a&#39;, &#39;z&#39;)))
//         )
//       ),
//       fn = cats.parse.Parser$$Lambda$13134/499005908@755cf173
//     ),
//     second = Void(
//       parser = CharIn(
//         min = 32,
//         bitSet = {0},
//         ranges = NonEmptyList(head = (&#39; &#39;, &#39; &#39;), tail = List())
//       )
//     )
//   ),
//   fn = cats.parse.Parser$$Lambda$13136/251357779@48f7dc64
// )
</span><span class="keyword">val</span><span> </span><span class="identifier">p5</span><span>: </span><span class="type-name">Parser</span><span>[</span><span class="type-name">Char</span><span>] = </span><span class="identifier">alpha</span><span>.</span><span class="identifier">surroundedBy</span><span>(</span><span class="identifier">sp</span><span>)
</span><span class="comment">// p5: Parser[Char] = Map(
//   parser = Prod(
//     first = Void(
//       parser = CharIn(
//         min = 32,
//         bitSet = {0},
//         ranges = NonEmptyList(head = (&#39; &#39;, &#39; &#39;), tail = List())
//       )
//     ),
//     second = Prod(
//       first = CharIn(
//         min = 65,
//         bitSet = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57},
//         ranges = NonEmptyList(head = (&#39;A&#39;, &#39;Z&#39;), tail = List((&#39;a&#39;, &#39;z&#39;)))
//       ),
//       second = Void(
//         parser = CharIn(
//           min = 32,
//           bitSet = {0},
//           ranges = NonEmptyList(head = (&#39; &#39;, &#39; &#39;), tail = List())
//         )
//       )
//     )
//   ),
//   fn = cats.parse.Parser$$Lambda$13137/1549135297@7aaa8f51
// )
</span><span>
</span><span class="identifier">p4</span><span>.</span><span class="identifier">parse</span><span>(</span><span class="string-literal">&quot; a &quot;</span><span>)
</span><span class="comment">// res14: Either[Parser.Error, (String, Char)] = Right(value = (&quot;&quot;, &#39;a&#39;))
// res0: Either[Error, Tuple2[String, Char]] = Right((,a))
</span><span class="identifier">p5</span><span>.</span><span class="identifier">parse</span><span>(</span><span class="string-literal">&quot; a &quot;</span><span>)
</span><span class="comment">// res15: Either[Parser.Error, (String, Char)] = Right(value = (&quot;&quot;, &#39;a&#39;))
// res1: Either[Error, Tuple2[String, Char]] = Right((,a))
</span><span>
</span><span class="comment">/* between */</span><span>

</span><span class="keyword">val</span><span> </span><span class="identifier">p6</span><span>: </span><span class="type-name">Parser</span><span>[</span><span class="type-name">Char</span><span>] = </span><span class="identifier">sp</span><span> *&gt; </span><span class="identifier">alpha</span><span> &lt;* </span><span class="identifier">digit</span><span>
</span><span class="comment">// p6: Parser[Char] = Map(
//   parser = Prod(
//     first = Map(
//       parser = Prod(
//         first = Void(
//           parser = CharIn(
//             min = 32,
//             bitSet = {0},
//             ranges = NonEmptyList(head = (&#39; &#39;, &#39; &#39;), tail = List())
//           )
//         ),
//         second = CharIn(
//           min = 65,
//           bitSet = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57},
//           ranges = NonEmptyList(head = (&#39;A&#39;, &#39;Z&#39;), tail = List((&#39;a&#39;, &#39;z&#39;)))
//         )
//       ),
//       fn = cats.parse.Parser$$Lambda$13134/499005908@755cf173
//     ),
//     second = Void(
//       parser = CharIn(
//         min = 48,
//         bitSet = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9},
//         ranges = NonEmptyList(head = (&#39;0&#39;, &#39;9&#39;), tail = List())
//       )
//     )
//   ),
//   fn = cats.parse.Parser$$Lambda$13136/251357779@48f7dc64
// )
</span><span class="keyword">val</span><span> </span><span class="identifier">p7</span><span>: </span><span class="type-name">Parser</span><span>[</span><span class="type-name">Char</span><span>] = </span><span class="identifier">alpha</span><span>.</span><span class="identifier">between</span><span>(</span><span class="identifier">sp</span><span>, </span><span class="identifier">digit</span><span>)
</span><span class="comment">// p7: Parser[Char] = Map(
//   parser = Prod(
//     first = Void(
//       parser = CharIn(
//         min = 32,
//         bitSet = {0},
//         ranges = NonEmptyList(head = (&#39; &#39;, &#39; &#39;), tail = List())
//       )
//     ),
//     second = Prod(
//       first = CharIn(
//         min = 65,
//         bitSet = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57},
//         ranges = NonEmptyList(head = (&#39;A&#39;, &#39;Z&#39;), tail = List((&#39;a&#39;, &#39;z&#39;)))
//       ),
//       second = Void(
//         parser = CharIn(
//           min = 48,
//           bitSet = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9},
//           ranges = NonEmptyList(head = (&#39;0&#39;, &#39;9&#39;), tail = List())
//         )
//       )
//     )
//   ),
//   fn = cats.parse.Parser$$Lambda$13137/1549135297@7aaa8f51
// )
</span><span>
</span><span class="identifier">p6</span><span>.</span><span class="identifier">parse</span><span>(</span><span class="string-literal">&quot; a1&quot;</span><span>)
</span><span class="comment">// res16: Either[Parser.Error, (String, Char)] = Right(value = (&quot;&quot;, &#39;a&#39;))
// res2: Either[Error, Tuple2[String, Char]] = Right((,a))
</span><span class="identifier">p7</span><span>.</span><span class="identifier">parse</span><span>(</span><span class="string-literal">&quot; a1&quot;</span><span>)
</span><span class="comment">// res17: Either[Parser.Error, (String, Char)] = Right(value = (&quot;&quot;, &#39;a&#39;))
// res3: Either[Error, Tuple2[String, Char]] = Right((,a))
</span><span>
</span><span class="comment">/* OrElse */</span><span>

</span><span class="keyword">val</span><span> </span><span class="identifier">p3</span><span>: </span><span class="type-name">Parser</span><span>[</span><span class="type-name">AnyVal</span><span>] = </span><span class="identifier">alpha</span><span> | </span><span class="identifier">sp</span><span>
</span><span class="comment">// p3: Parser[AnyVal] = OneOf(
//   all = List(
//     CharIn(
//       min = 65,
//       bitSet = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57},
//       ranges = NonEmptyList(head = (&#39;A&#39;, &#39;Z&#39;), tail = List((&#39;a&#39;, &#39;z&#39;)))
//     ),
//     Void(
//       parser = CharIn(
//         min = 32,
//         bitSet = {0},
//         ranges = NonEmptyList(head = (&#39; &#39;, &#39; &#39;), tail = List())
//       )
//     )
//   )
// )
</span><span>
</span><span class="identifier">p3</span><span>.</span><span class="identifier">parse</span><span>(</span><span class="string-literal">&quot;t&quot;</span><span>)
</span><span class="comment">// res18: Either[Parser.Error, (String, AnyVal)] = Right(value = (&quot;&quot;, &#39;t&#39;))
// res4: Either[Error, Tuple2[String, AnyVal]] = Right((,t))
</span><span class="identifier">p3</span><span>.</span><span class="identifier">parse</span><span>(</span><span class="string-literal">&quot; &quot;</span><span>)
</span><span class="comment">// res19: Either[Parser.Error, (String, AnyVal)] = Right(value = (&quot;&quot;, ()))</span></code></pre>
        
        <h2 id="repeating-parsers" class="section">Repeating parsers<a class="anchor-link right" href="#repeating-parsers"><i class="icofont-laika">&#xef71;</i></a></h2>
        <p>Sometimes we need something to repeat zero or more types. The cats-parse have <code>rep</code> and <code>rep0</code> methods for repeating values. <code>rep</code> means that the parser must be successful <em>at least one time</em>. <code>rep0</code> means that the parser output might be empty.</p>
        <pre><code class="nohighlight"><span class="keyword">import</span><span> </span><span class="identifier">cats</span><span>.</span><span class="identifier">data</span><span>.</span><span class="type-name">NonEmptyList</span><span>
</span><span class="keyword">import</span><span> </span><span class="identifier">cats</span><span>.</span><span class="identifier">parse</span><span>.</span><span class="type-name">Rfc5234</span><span>.</span><span class="identifier">alpha</span><span>
</span><span class="keyword">import</span><span> </span><span class="identifier">cats</span><span>.</span><span class="identifier">parse</span><span>.{</span><span class="type-name">Parser</span><span>, </span><span class="type-name">Parser0</span><span>}

</span><span class="keyword">val</span><span> </span><span class="identifier">p1</span><span>: </span><span class="type-name">Parser</span><span>[</span><span class="type-name">NonEmptyList</span><span>[</span><span class="type-name">Char</span><span>]]  = </span><span class="identifier">alpha</span><span>.</span><span class="identifier">rep</span><span>
</span><span class="comment">// p1: Parser[NonEmptyList[Char]] = Rep(
//   p1 = CharIn(
//     min = 65,
//     bitSet = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57},
//     ranges = NonEmptyList(head = (&#39;A&#39;, &#39;Z&#39;), tail = List((&#39;a&#39;, &#39;z&#39;)))
//   ),
//   min = 1,
//   maxMinusOne = 2147483647,
//   acc1 = cats.parse.Accumulator$$anon$12@cc8689c
// )
</span><span class="keyword">val</span><span> </span><span class="identifier">p2</span><span>: </span><span class="type-name">Parser0</span><span>[</span><span class="type-name">List</span><span>[</span><span class="type-name">Char</span><span>]] = </span><span class="identifier">alpha</span><span>.</span><span class="identifier">rep0</span><span>
</span><span class="comment">// p2: Parser0[List[Char]] = OneOf0(
//   all = List(
//     Rep(
//       p1 = CharIn(
//         min = 65,
//         bitSet = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57},
//         ranges = NonEmptyList(head = (&#39;A&#39;, &#39;Z&#39;), tail = List((&#39;a&#39;, &#39;z&#39;)))
//       ),
//       min = 1,
//       maxMinusOne = 2147483647,
//       acc1 = cats.parse.Accumulator0$$anon$9@1e0dd71f
//     ),
//     Pure(result = List())
//   )
// )
</span><span>
</span><span class="identifier">p1</span><span>.</span><span class="identifier">parse</span><span>(</span><span class="string-literal">&quot;&quot;</span><span>)
</span><span class="comment">// res21: Either[Parser.Error, (String, NonEmptyList[Char])] = Left(
//   value = Error(
//      = 0,
//      = NonEmptyList(
//       head = InRange(offset = 0, lower = &#39;A&#39;, upper = &#39;Z&#39;),
//       tail = List(InRange(offset = 0, lower = &#39;a&#39;, upper = &#39;z&#39;))
//     )
//   )
// )
// Left(Error(0,NonEmptyList(InRange(0,A,Z), InRange(0,a,z))))
</span><span class="identifier">p2</span><span>.</span><span class="identifier">parse</span><span>(</span><span class="string-literal">&quot;&quot;</span><span>)
</span><span class="comment">// res22: Either[Parser.Error, (String, List[Char])] = Right(
//   value = (&quot;&quot;, List())
// )
// Right((,List()))
</span><span class="identifier">p2</span><span>.</span><span class="identifier">parse</span><span>(</span><span class="string-literal">&quot;something&quot;</span><span>)
</span><span class="comment">// res23: Either[Parser.Error, (String, List[Char])] = Right(
//   value = (&quot;&quot;, List(&#39;s&#39;, &#39;o&#39;, &#39;m&#39;, &#39;e&#39;, &#39;t&#39;, &#39;h&#39;, &#39;i&#39;, &#39;n&#39;, &#39;g&#39;))
// )</span></code></pre>
        <p>Notice the types of parsers. <code>Parser</code> type always means some non-empty output and the output of <code>Parser0</code> might be empty.</p>
        <p>One common task in this example is to parse a full line (or words) of text. In the example it is done by <code>rep</code>, and then it could be mapped to <code>String</code> in different ways:</p>
        <pre><code class="nohighlight"><span class="keyword">import</span><span> </span><span class="identifier">cats</span><span>.</span><span class="identifier">data</span><span>.</span><span class="type-name">NonEmptyList</span><span>
</span><span class="keyword">import</span><span> </span><span class="identifier">cats</span><span>.</span><span class="identifier">parse</span><span>.</span><span class="type-name">Rfc5234</span><span>.</span><span class="identifier">alpha</span><span>
</span><span class="keyword">import</span><span> </span><span class="identifier">cats</span><span>.</span><span class="identifier">parse</span><span>.</span><span class="type-name">Parser</span><span>

</span><span class="keyword">val</span><span> </span><span class="identifier">p</span><span>: </span><span class="type-name">Parser</span><span>[</span><span class="type-name">String</span><span>]  = </span><span class="identifier">alpha</span><span>.</span><span class="identifier">rep</span><span>.</span><span class="identifier">map</span><span>((</span><span class="identifier">l</span><span>: </span><span class="type-name">NonEmptyList</span><span>[</span><span class="type-name">Char</span><span>]) =&gt; </span><span class="identifier">l</span><span>.</span><span class="identifier">toList</span><span>.</span><span class="identifier">mkString</span><span>)
</span><span class="comment">// p: Parser[String] = Map(
//   parser = Rep(
//     p1 = CharIn(
//       min = 65,
//       bitSet = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57},
//       ranges = NonEmptyList(head = (&#39;A&#39;, &#39;Z&#39;), tail = List((&#39;a&#39;, &#39;z&#39;)))
//     ),
//     min = 1,
//     maxMinusOne = 2147483647,
//     acc1 = cats.parse.Accumulator$$anon$12@6ec1474b
//   ),
//   fn = &lt;function1&gt;
// )
</span><span>
</span><span class="keyword">val</span><span> </span><span class="identifier">p2</span><span>: </span><span class="type-name">Parser</span><span>[</span><span class="type-name">String</span><span>] = </span><span class="identifier">alpha</span><span>.</span><span class="identifier">rep</span><span>.</span><span class="identifier">string</span><span>
</span><span class="comment">// p2: Parser[String] = StringP(
//   parser = Rep(
//     p1 = CharIn(
//       min = 65,
//       bitSet = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57},
//       ranges = NonEmptyList(head = (&#39;A&#39;, &#39;Z&#39;), tail = List((&#39;a&#39;, &#39;z&#39;)))
//     ),
//     min = 1,
//     maxMinusOne = 2147483647,
//     acc1 = cats.parse.Accumulator0$$anon$11@403f9dc5
//   )
// )
</span><span class="keyword">val</span><span> </span><span class="identifier">p3</span><span>: </span><span class="type-name">Parser</span><span>[</span><span class="type-name">String</span><span>] = </span><span class="identifier">alpha</span><span>.</span><span class="identifier">repAs</span><span>[</span><span class="type-name">String</span><span>]
</span><span class="comment">// p3: Parser[String] = Rep(
//   p1 = CharIn(
//     min = 65,
//     bitSet = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57},
//     ranges = NonEmptyList(head = (&#39;A&#39;, &#39;Z&#39;), tail = List((&#39;a&#39;, &#39;z&#39;)))
//   ),
//   min = 1,
//   maxMinusOne = 2147483647,
//   acc1 = cats.parse.Accumulator0$$anon$7@ffc91d6
// )</span></code></pre>
        <p>All three parsers will be identical in parsing results, but <code>p2</code> and <code>p3</code> are using built-in methods which will not create intermediate list. <code>rep</code> + <code>map</code> creates intermediate list which is mapped to string in this example.</p>
        
        <h2 id="parsers-with-empty-output" class="section">Parsers with empty output<a class="anchor-link right" href="#parsers-with-empty-output"><i class="icofont-laika">&#xef71;</i></a></h2>
        <p>Some parsers never return a value. They have a type <code>Parser0</code>. One might get this type of parser when using <code>rep0</code> or <code>.?</code> methods.</p>
        <pre><code class="nohighlight"><span class="keyword">import</span><span> </span><span class="identifier">cats</span><span>.</span><span class="identifier">parse</span><span>.</span><span class="type-name">Rfc5234</span><span>.{</span><span class="identifier">alpha</span><span>, </span><span class="identifier">sp</span><span>}
</span><span class="keyword">import</span><span> </span><span class="identifier">cats</span><span>.</span><span class="identifier">parse</span><span>.</span><span class="type-name">Parser</span><span>

</span><span class="keyword">val</span><span> </span><span class="identifier">p</span><span>: </span><span class="type-name">Parser</span><span>[</span><span class="type-name">String</span><span>] = (</span><span class="identifier">alpha</span><span>.</span><span class="identifier">rep</span><span> &lt;* </span><span class="identifier">sp</span><span>.?).</span><span class="identifier">rep</span><span>.</span><span class="identifier">string</span><span>
</span><span class="comment">// p: Parser[String] = StringP(
//   parser = Rep(
//     p1 = Prod(
//       first = Rep(
//         p1 = CharIn(
//           min = 65,
//           bitSet = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57},
//           ranges = NonEmptyList(head = (&#39;A&#39;, &#39;Z&#39;), tail = List((&#39;a&#39;, &#39;z&#39;)))
//         ),
//         min = 1,
//         maxMinusOne = 2147483647,
//         acc1 = cats.parse.Accumulator0$$anon$11@403f9dc5
//       ),
//       second = OneOf0(
//         all = List(
//           CharIn(
//             min = 32,
//             bitSet = {0},
//             ranges = NonEmptyList(head = (&#39; &#39;, &#39; &#39;), tail = List())
//           ),
//           Pure(result = ())
//         )
//       )
//     ),
//     min = 1,
//     maxMinusOne = 2147483647,
//     acc1 = cats.parse.Accumulator0$$anon$11@403f9dc5
//   )
// )
</span><span>
</span><span class="identifier">p</span><span>.</span><span class="identifier">parse</span><span>(</span><span class="string-literal">&quot;hello world&quot;</span><span>)
</span><span class="comment">// res26: Either[Parser.Error, (String, String)] = Right(
//   value = (&quot;&quot;, &quot;hello world&quot;)
// )</span></code></pre>
        <p>Notice the type we got - <code>Parser[String]</code>. That is because we have <code>rep</code> outside and our <code>alpha.rep</code> parser with <code>Parser</code> type is on the left side of the clause. But what if we want to parse strings with spaces at the beginning?</p>
        <pre class="keep-together pdf epub"><code class="scala:fail">val p = (sp.? *&gt; alpha.rep &lt;* sp.?).rep.string</code></pre>
        <p>We will get an error <code>value rep is not a member of cats.parse.Parser0</code>. This happens since we have the left-side parser as optional in <code>sp.? *&gt; alpha.rep &lt;* sp.?</code> clause. This clause has a type <code>Parser0</code> which can&#39;t be repeated.</p>
        <p>But this parser can&#39;t be empty because of <code>alpha.rep</code> parser, and we know it. For these types of parsers we need to use <code>with1</code> wrapper method on the <em>left side</em> of the clause:</p>
        <pre><code class="nohighlight"><span class="keyword">import</span><span> </span><span class="identifier">cats</span><span>.</span><span class="identifier">parse</span><span>.</span><span class="type-name">Rfc5234</span><span>.{</span><span class="identifier">alpha</span><span>, </span><span class="identifier">sp</span><span>}
</span><span class="keyword">import</span><span> </span><span class="identifier">cats</span><span>.</span><span class="identifier">parse</span><span>.</span><span class="type-name">Parser</span><span>


</span><span class="keyword">val</span><span> </span><span class="identifier">p</span><span>: </span><span class="type-name">Parser</span><span>[</span><span class="type-name">String</span><span>] = (</span><span class="identifier">sp</span><span>.?.</span><span class="identifier">with1</span><span> *&gt; </span><span class="identifier">alpha</span><span>.</span><span class="identifier">rep</span><span> &lt;* </span><span class="identifier">sp</span><span>.?).</span><span class="identifier">rep</span><span>.</span><span class="identifier">string</span><span>
</span><span class="comment">// p: Parser[String] = StringP(
//   parser = Rep(
//     p1 = Prod(
//       first = OneOf0(
//         all = List(
//           CharIn(
//             min = 32,
//             bitSet = {0},
//             ranges = NonEmptyList(head = (&#39; &#39;, &#39; &#39;), tail = List())
//           ),
//           Pure(result = ())
//         )
//       ),
//       second = Prod(
//         first = Rep(
//           p1 = CharIn(
//             min = 65,
//             bitSet = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57},
//             ranges = NonEmptyList(head = (&#39;A&#39;, &#39;Z&#39;), tail = List((&#39;a&#39;, &#39;z&#39;)))
//           ),
//           min = 1,
//           maxMinusOne = 2147483647,
//           acc1 = cats.parse.Accumulator0$$anon$11@403f9dc5
//         ),
//         second = OneOf0(
//           all = List(
//             CharIn(
//               min = 32,
//               bitSet = {0},
//               ranges = NonEmptyList(head = (&#39; &#39;, &#39; &#39;), tail = List())
//             ),
//             Pure(result = ())
//           )
//         )
//       )
//     ),
//     min = 1,
//     maxMinusOne = 2147483647,
//     acc1 = cats.parse.Accumulator0$$anon$11@403f9dc5
//   )
// )
</span><span>
</span><span class="identifier">p</span><span>.</span><span class="identifier">parse</span><span>(</span><span class="string-literal">&quot;hello world&quot;</span><span>)
</span><span class="comment">// res28: Either[Parser.Error, (String, String)] = Right(
//   value = (&quot;&quot;, &quot;hello world&quot;)
// )
// res0: Either[Error, Tuple2[String, String]] = Right((,hello world))
</span><span class="identifier">p</span><span>.</span><span class="identifier">parse</span><span>(</span><span class="string-literal">&quot; hello world&quot;</span><span>)
</span><span class="comment">// res29: Either[Parser.Error, (String, String)] = Right(
//   value = (&quot;&quot;, &quot; hello world&quot;)
// )</span></code></pre>
        <p>If we have multiple <code>Parser0</code> parsers before the <code>Parser</code> - we&#39;d need to use parenthesis like this:
        <code>(sp.? ~ sp.?).with1 *&gt; alpha.rep</code>.</p>
        
        <h2 id="error-handling" class="section">Error handling<a class="anchor-link right" href="#error-handling"><i class="icofont-laika">&#xef71;</i></a></h2>
        <p>Parser might be interrupted by parsing error. There are two kinds of errors:</p>
        <ul>
          <li>an error that has consumed 0 characters (<strong>epsilon failure</strong>);</li>
          <li>an error that has consumed 1 or more characters (<strong>arresting failure</strong>) (sometimes called halting failure).</li>
        </ul>
        <pre><code class="nohighlight"><span class="keyword">import</span><span> </span><span class="identifier">cats</span><span>.</span><span class="identifier">parse</span><span>.</span><span class="type-name">Rfc5234</span><span>.{</span><span class="identifier">alpha</span><span>, </span><span class="identifier">sp</span><span>}
</span><span class="keyword">import</span><span> </span><span class="identifier">cats</span><span>.</span><span class="identifier">parse</span><span>.</span><span class="type-name">Parser</span><span>

</span><span class="keyword">val</span><span> </span><span class="identifier">p1</span><span>: </span><span class="type-name">Parser</span><span>[</span><span class="type-name">Char</span><span>] = </span><span class="identifier">alpha</span><span>
</span><span class="comment">// p1: Parser[Char] = CharIn(
//   min = 65,
//   bitSet = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57},
//   ranges = NonEmptyList(head = (&#39;A&#39;, &#39;Z&#39;), tail = List((&#39;a&#39;, &#39;z&#39;)))
// )
</span><span class="keyword">val</span><span> </span><span class="identifier">p2</span><span>: </span><span class="type-name">Parser</span><span>[</span><span class="type-name">Char</span><span>] = </span><span class="identifier">sp</span><span> *&gt; </span><span class="identifier">alpha</span><span>
</span><span class="comment">// p2: Parser[Char] = Map(
//   parser = Prod(
//     first = Void(
//       parser = CharIn(
//         min = 32,
//         bitSet = {0},
//         ranges = NonEmptyList(head = (&#39; &#39;, &#39; &#39;), tail = List())
//       )
//     ),
//     second = CharIn(
//       min = 65,
//       bitSet = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57},
//       ranges = NonEmptyList(head = (&#39;A&#39;, &#39;Z&#39;), tail = List((&#39;a&#39;, &#39;z&#39;)))
//     )
//   ),
//   fn = cats.parse.Parser$$Lambda$13134/499005908@755cf173
// )
</span><span>
</span><span class="comment">// epsilon failure
</span><span class="identifier">p1</span><span>.</span><span class="identifier">parse</span><span>(</span><span class="string-literal">&quot;123&quot;</span><span>)
</span><span class="comment">// res31: Either[Parser.Error, (String, Char)] = Left(
//   value = Error(
//      = 0,
//      = NonEmptyList(
//       head = InRange(offset = 0, lower = &#39;A&#39;, upper = &#39;Z&#39;),
//       tail = List(InRange(offset = 0, lower = &#39;a&#39;, upper = &#39;z&#39;))
//     )
//   )
// )
// res0: Either[Error, Tuple2[String, Char]] = Left(Error(0,NonEmptyList(InRange(0,A,Z), InRange(0,a,z))))
</span><span>
</span><span class="comment">// arresting failure
</span><span class="identifier">p2</span><span>.</span><span class="identifier">parse</span><span>(</span><span class="string-literal">&quot; 1&quot;</span><span>)
</span><span class="comment">// res32: Either[Parser.Error, (String, Char)] = Left(
//   value = Error(
//      = 1,
//      = NonEmptyList(
//       head = InRange(offset = 1, lower = &#39;A&#39;, upper = &#39;Z&#39;),
//       tail = List(InRange(offset = 1, lower = &#39;a&#39;, upper = &#39;z&#39;))
//     )
//   )
// )</span></code></pre>
        <p>We need to make this difference because the first type of error allows us to say that parser is not matching the input before we started to process it and the second error happens while parser processing the input.</p>
        
        <h3 id="backtrack" class="section">Backtrack<a class="anchor-link right" href="#backtrack"><i class="icofont-laika">&#xef71;</i></a></h3>
        <p>Backtrack allows us to convert an <em>arresting failure</em> to <em>epsilon failure</em>. It also rewinds the input to the offset to that used before parsing began. The resulting parser might still be combined with others. Let&#39;s look at the example:</p>
        <pre><code class="nohighlight"><span class="keyword">import</span><span> </span><span class="identifier">cats</span><span>.</span><span class="identifier">parse</span><span>.</span><span class="type-name">Rfc5234</span><span>.{</span><span class="identifier">digit</span><span>, </span><span class="identifier">sp</span><span>}

</span><span class="keyword">val</span><span> </span><span class="identifier">p</span><span> = </span><span class="identifier">sp</span><span> *&gt; </span><span class="identifier">digit</span><span> &lt;* </span><span class="identifier">sp</span><span>
</span><span class="comment">// p: cats.parse.Parser[Char] = Map(
//   parser = Prod(
//     first = Map(
//       parser = Prod(
//         first = Void(
//           parser = CharIn(
//             min = 32,
//             bitSet = {0},
//             ranges = NonEmptyList(head = (&#39; &#39;, &#39; &#39;), tail = List())
//           )
//         ),
//         second = CharIn(
//           min = 48,
//           bitSet = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9},
//           ranges = NonEmptyList(head = (&#39;0&#39;, &#39;9&#39;), tail = List())
//         )
//       ),
//       fn = cats.parse.Parser$$Lambda$13134/499005908@755cf173
//     ),
//     second = Void(
//       parser = CharIn(
//         min = 32,
//         bitSet = {0},
//         ranges = NonEmptyList(head = (&#39; &#39;, &#39; &#39;), tail = List())
//       )
//     )
//   ),
//   fn = cats.parse.Parser$$Lambda$13136/251357779@48f7dc64
// )
</span><span>
</span><span class="identifier">p</span><span>.</span><span class="identifier">parse</span><span>(</span><span class="string-literal">&quot; 1&quot;</span><span>)
</span><span class="comment">// res34: Either[cats.parse.Parser.Error, (String, Char)] = Left(
//   value = Error(
//      = 2,
//      = NonEmptyList(
//       head = InRange(offset = 2, lower = &#39; &#39;, upper = &#39; &#39;),
//       tail = List()
//     )
//   )
// )</span></code></pre>
        <p><code>Parser.Error</code> contains two parameters:</p>
        <pre class="keep-together pdf epub"><code class="nohighlight"><span class="keyword">final</span><span> </span><span class="keyword">case</span><span> </span><span class="keyword">class</span><span> </span><span class="type-name">Error</span><span>(</span><span class="identifier">input</span><span>: </span><span class="type-name">String</span><span>, </span><span class="identifier">failedAtOffset</span><span>: </span><span class="type-name">Int</span><span>, </span><span class="identifier">expected</span><span>: </span><span class="type-name">NonEmptyList</span><span>[</span><span class="type-name">Expectation</span><span>])

</span><span class="keyword">case</span><span> </span><span class="keyword">class</span><span> </span><span class="type-name">InRange</span><span>(</span><span class="identifier">offset</span><span>: </span><span class="type-name">Int</span><span>, </span><span class="identifier">lower</span><span>: </span><span class="type-name">Char</span><span>, </span><span class="identifier">upper</span><span>: </span><span class="type-name">Char</span><span>) </span><span class="keyword">extends</span><span> </span><span class="type-name">Expectation</span></code></pre>
        <p>In the error message we see the failed offset and the expected value. There is a lot of expected error types which can be found in source code.</p>
        <p>One thing we can do in this situation is providing a fallback parser which can be used in case of error. We can do this by using <code>backtrack</code> (which rewinds the input, so it will be passed to fallback parser as it was before the error) and combining it with <code>orElse</code> operator:</p>
        <pre><code class="nohighlight"><span class="keyword">import</span><span> </span><span class="identifier">cats</span><span>.</span><span class="identifier">parse</span><span>.</span><span class="type-name">Rfc5234</span><span>.{</span><span class="identifier">digit</span><span>, </span><span class="identifier">sp</span><span>}

</span><span class="keyword">val</span><span> </span><span class="identifier">p1</span><span> = </span><span class="identifier">sp</span><span> *&gt; </span><span class="identifier">digit</span><span> &lt;* </span><span class="identifier">sp</span><span>
</span><span class="comment">// p1: cats.parse.Parser[Char] = Map(
//   parser = Prod(
//     first = Map(
//       parser = Prod(
//         first = Void(
//           parser = CharIn(
//             min = 32,
//             bitSet = {0},
//             ranges = NonEmptyList(head = (&#39; &#39;, &#39; &#39;), tail = List())
//           )
//         ),
//         second = CharIn(
//           min = 48,
//           bitSet = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9},
//           ranges = NonEmptyList(head = (&#39;0&#39;, &#39;9&#39;), tail = List())
//         )
//       ),
//       fn = cats.parse.Parser$$Lambda$13134/499005908@755cf173
//     ),
//     second = Void(
//       parser = CharIn(
//         min = 32,
//         bitSet = {0},
//         ranges = NonEmptyList(head = (&#39; &#39;, &#39; &#39;), tail = List())
//       )
//     )
//   ),
//   fn = cats.parse.Parser$$Lambda$13136/251357779@48f7dc64
// )
</span><span class="keyword">val</span><span> </span><span class="identifier">p2</span><span> = </span><span class="identifier">sp</span><span> *&gt; </span><span class="identifier">digit</span><span>
</span><span class="comment">// p2: cats.parse.Parser[Char] = Map(
//   parser = Prod(
//     first = Void(
//       parser = CharIn(
//         min = 32,
//         bitSet = {0},
//         ranges = NonEmptyList(head = (&#39; &#39;, &#39; &#39;), tail = List())
//       )
//     ),
//     second = CharIn(
//       min = 48,
//       bitSet = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9},
//       ranges = NonEmptyList(head = (&#39;0&#39;, &#39;9&#39;), tail = List())
//     )
//   ),
//   fn = cats.parse.Parser$$Lambda$13134/499005908@755cf173
// )
</span><span>
</span><span class="identifier">p1</span><span>.</span><span class="identifier">backtrack</span><span>.</span><span class="identifier">orElse</span><span>(</span><span class="identifier">p2</span><span>).</span><span class="identifier">parse</span><span>(</span><span class="string-literal">&quot; 1&quot;</span><span>)
</span><span class="comment">// res36: Either[cats.parse.Parser.Error, (String, Char)] = Right(
//   value = (&quot;&quot;, &#39;1&#39;)
// )
// res0: Either[Error, Tuple2[String, Char]] = Right((,1))
</span><span>(</span><span class="identifier">p1</span><span>.</span><span class="identifier">backtrack</span><span> | </span><span class="identifier">p2</span><span> ).</span><span class="identifier">parse</span><span>(</span><span class="string-literal">&quot; 1&quot;</span><span>)
</span><span class="comment">// res37: Either[cats.parse.Parser.Error, (String, Char)] = Right(
//   value = (&quot;&quot;, &#39;1&#39;)
// )</span></code></pre>
        <p>Notice that <code>(p1.backtrack | p2)</code> clause is another parser by itself since we&#39;re still combining parsers by using <code>orElse</code>.</p>
        <p>But we&#39;ve already used <code>orElse</code> in example before without any <code>backtrack</code> operator, and it worked just fine. Why do we need <code>backtrack</code> now? Let&#39;s look at this example:</p>
        <pre><code class="nohighlight"><span class="keyword">import</span><span> </span><span class="identifier">cats</span><span>.</span><span class="identifier">parse</span><span>.</span><span class="type-name">Rfc5234</span><span>.{</span><span class="identifier">digit</span><span>, </span><span class="identifier">sp</span><span>}

</span><span class="keyword">val</span><span> </span><span class="identifier">p1</span><span> = </span><span class="identifier">sp</span><span> *&gt; </span><span class="identifier">digit</span><span> &lt;* </span><span class="identifier">sp</span><span>
</span><span class="comment">// p1: cats.parse.Parser[Char] = Map(
//   parser = Prod(
//     first = Map(
//       parser = Prod(
//         first = Void(
//           parser = CharIn(
//             min = 32,
//             bitSet = {0},
//             ranges = NonEmptyList(head = (&#39; &#39;, &#39; &#39;), tail = List())
//           )
//         ),
//         second = CharIn(
//           min = 48,
//           bitSet = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9},
//           ranges = NonEmptyList(head = (&#39;0&#39;, &#39;9&#39;), tail = List())
//         )
//       ),
//       fn = cats.parse.Parser$$Lambda$13134/499005908@755cf173
//     ),
//     second = Void(
//       parser = CharIn(
//         min = 32,
//         bitSet = {0},
//         ranges = NonEmptyList(head = (&#39; &#39;, &#39; &#39;), tail = List())
//       )
//     )
//   ),
//   fn = cats.parse.Parser$$Lambda$13136/251357779@48f7dc64
// )
</span><span class="keyword">val</span><span> </span><span class="identifier">p2</span><span> = </span><span class="identifier">sp</span><span> *&gt; </span><span class="identifier">digit</span><span>
</span><span class="comment">// p2: cats.parse.Parser[Char] = Map(
//   parser = Prod(
//     first = Void(
//       parser = CharIn(
//         min = 32,
//         bitSet = {0},
//         ranges = NonEmptyList(head = (&#39; &#39;, &#39; &#39;), tail = List())
//       )
//     ),
//     second = CharIn(
//       min = 48,
//       bitSet = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9},
//       ranges = NonEmptyList(head = (&#39;0&#39;, &#39;9&#39;), tail = List())
//     )
//   ),
//   fn = cats.parse.Parser$$Lambda$13134/499005908@755cf173
// )
</span><span class="keyword">val</span><span> </span><span class="identifier">p3</span><span> = </span><span class="identifier">digit</span><span>
</span><span class="comment">// p3: cats.parse.Parser[Char] = CharIn(
//   min = 48,
//   bitSet = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9},
//   ranges = NonEmptyList(head = (&#39;0&#39;, &#39;9&#39;), tail = List())
// )
</span><span>
(</span><span class="identifier">p1</span><span> | </span><span class="identifier">p2</span><span>).</span><span class="identifier">parse</span><span>(</span><span class="string-literal">&quot; 1&quot;</span><span>)
</span><span class="comment">// res39: Either[cats.parse.Parser.Error, (String, Char)] = Left(
//   value = Error(
//      = 2,
//      = NonEmptyList(
//       head = InRange(offset = 2, lower = &#39; &#39;, upper = &#39; &#39;),
//       tail = List()
//     )
//   )
// )
// res1 = Left(Error(2,NonEmptyList(InRange(2, , ))))
</span><span>
(</span><span class="identifier">p1</span><span> | </span><span class="identifier">p2</span><span> | </span><span class="identifier">p3</span><span>).</span><span class="identifier">parse</span><span>(</span><span class="string-literal">&quot;1&quot;</span><span>)
</span><span class="comment">// res40: Either[cats.parse.Parser.Error, (String, Char)] = Right(
//   value = (&quot;&quot;, &#39;1&#39;)
// )</span></code></pre>
        <p>The first parser combination is interrupted by <em>arresting failures</em> and the second parsing combination will only suffer from <em>epsilon failures</em>. The second parser works because <code>orElse</code> and <code>|</code> operators actually allows recovering from epsilon failures, but not from arresting failures.</p>
        <p>So the <code>backtrack</code> helps us where the <em>left side</em> returns arresting failure.</p>
        
        <h3 id="soft" class="section">Soft<a class="anchor-link right" href="#soft"><i class="icofont-laika">&#xef71;</i></a></h3>
        <p>This method might look similar to <code>backtrack</code>, but it allows us to <em>proceed</em> the parsing when the <em>right side</em> is returning an epsilon failure. It is really useful for ambiguous parsers when we can&#39;t really tell what exactly we are parsing before the end. Let&#39;s say we want to parse some input to the search engine which contains fields. This might look like &quot;field:search_query&quot;. Let&#39;s try to write a parser for this:</p>
        <pre><code class="nohighlight"><span class="keyword">import</span><span> </span><span class="identifier">cats</span><span>.</span><span class="identifier">parse</span><span>.</span><span class="type-name">Rfc5234</span><span>.{</span><span class="identifier">alpha</span><span>, </span><span class="identifier">sp</span><span>}
</span><span class="keyword">import</span><span> </span><span class="identifier">cats</span><span>.</span><span class="identifier">parse</span><span>.</span><span class="type-name">Parser</span><span>
</span><span class="keyword">import</span><span> </span><span class="identifier">cats</span><span>.</span><span class="identifier">parse</span><span>.</span><span class="type-name">Parser</span><span>.{</span><span class="identifier">char</span><span> =&gt; </span><span class="identifier">pchar</span><span>}

</span><span class="keyword">val</span><span> </span><span class="identifier">searchWord</span><span> = </span><span class="identifier">alpha</span><span>.</span><span class="identifier">rep</span><span>.</span><span class="identifier">string</span><span>
</span><span class="comment">// searchWord: Parser[String] = StringP(
//   parser = Rep(
//     p1 = CharIn(
//       min = 65,
//       bitSet = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57},
//       ranges = NonEmptyList(head = (&#39;A&#39;, &#39;Z&#39;), tail = List((&#39;a&#39;, &#39;z&#39;)))
//     ),
//     min = 1,
//     maxMinusOne = 2147483647,
//     acc1 = cats.parse.Accumulator0$$anon$11@403f9dc5
//   )
// )
</span><span>
</span><span class="keyword">val</span><span> </span><span class="identifier">fieldValue</span><span> = </span><span class="identifier">alpha</span><span>.</span><span class="identifier">rep</span><span>.</span><span class="identifier">string</span><span> ~ </span><span class="identifier">pchar</span><span>(</span><span class="char-literal">&#39;:&#39;</span><span>)
</span><span class="comment">// fieldValue: Parser[(String, Unit)] = Prod(
//   first = StringP(
//     parser = Rep(
//       p1 = CharIn(
//         min = 65,
//         bitSet = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57},
//         ranges = NonEmptyList(head = (&#39;A&#39;, &#39;Z&#39;), tail = List((&#39;a&#39;, &#39;z&#39;)))
//       ),
//       min = 1,
//       maxMinusOne = 2147483647,
//       acc1 = cats.parse.Accumulator0$$anon$11@403f9dc5
//     )
//   ),
//   second = Void(
//     parser = CharIn(
//       min = 58,
//       bitSet = {0},
//       ranges = NonEmptyList(head = (&#39;:&#39;, &#39;:&#39;), tail = List())
//     )
//   )
// )
</span><span>
</span><span class="keyword">val</span><span> </span><span class="identifier">p1</span><span> = </span><span class="identifier">fieldValue</span><span>.? ~ (</span><span class="identifier">searchWord</span><span> ~ </span><span class="identifier">sp</span><span>.?).</span><span class="identifier">rep</span><span>.</span><span class="identifier">string</span><span>
</span><span class="comment">// p1: cats.parse.Parser0[(Option[(String, Unit)], String)] = OneOf(
//   all = List(
//     Prod(
//       first = Map(
//         parser = Prod(
//           first = StringP(
//             parser = Rep(
//               p1 = CharIn(
//                 min = 65,
//                 bitSet = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57},
//                 ranges = NonEmptyList(
//                   head = (&#39;A&#39;, &#39;Z&#39;),
//                   tail = List((&#39;a&#39;, &#39;z&#39;))
//                 )
//               ),
//               min = 1,
//               maxMinusOne = 2147483647,
//               acc1 = cats.parse.Accumulator0$$anon$11@403f9dc5
//             )
//           ),
//           second = Void(
//             parser = CharIn(
//               min = 58,
//               bitSet = {0},
//               ranges = NonEmptyList(head = (&#39;:&#39;, &#39;:&#39;), tail = List())
//             )
//           )
//         ),
//         fn = cats.parse.Parser0$$Lambda$13126/1895385475@7f390a19
//       ),
//       second = StringP(
//         parser = Rep(
//           p1 = Prod(
//             first = Rep(
//               p1 = CharIn(
//                 min = 65,
//                 bitSet = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57},
//                 ranges = NonEmptyList(
//                   head = (&#39;A&#39;, &#39;Z&#39;),
//                   tail = List((&#39;a&#39;, &#39;z&#39;))
//                 )
//               ),
//               min = 1,
//               maxMinusOne = 2147483647,
//               acc1 = cats.parse.Accumulator0$$anon$11@403f9dc5
// ...
</span><span>

</span><span class="identifier">p1</span><span>.</span><span class="identifier">parse</span><span>(</span><span class="string-literal">&quot;title:The Wind Has Risen&quot;</span><span>)
</span><span class="comment">// res42: Either[Parser.Error, (String, (Option[(String, Unit)], String))] = Right(
//   value = (&quot;&quot;, (Some(value = (&quot;title&quot;, ())), &quot;The Wind Has Risen&quot;))
// )
// res0 = Right((,(Some((title,())),The Wind Has Risen)))
</span><span class="identifier">p1</span><span>.</span><span class="identifier">parse</span><span>(</span><span class="string-literal">&quot;The Wind Has Risen&quot;</span><span>)
</span><span class="comment">// res43: Either[Parser.Error, (String, (Option[(String, Unit)], String))] = Left(
//   value = Error(
//      = 3,
//      = NonEmptyList(
//       head = InRange(offset = 3, lower = &#39;:&#39;, upper = &#39;:&#39;),
//       tail = List()
//     )
//   )
// )</span></code></pre>
        <p>This error happens because we can&#39;t really tell if we are parsing the <code>fieldValue</code> before we met a <code>:</code> char. We might do this with by writing two parsers, converting the first one&#39;s failure to epsilon failure by <code>backtrack</code> and then providing fallback parser by <code>|</code> operator (which allows the epsilon failures):</p>
        <pre><code class="nohighlight"><span class="keyword">val</span><span> </span><span class="identifier">p2</span><span> = </span><span class="identifier">fieldValue</span><span>.? ~ (</span><span class="identifier">searchWord</span><span> ~ </span><span class="identifier">sp</span><span>.?).</span><span class="identifier">rep</span><span>.</span><span class="identifier">string</span><span>
</span><span class="comment">// p2: cats.parse.Parser0[(Option[(String, Unit)], String)] = OneOf(
//   all = List(
//     Prod(
//       first = Map(
//         parser = Prod(
//           first = StringP(
//             parser = Rep(
//               p1 = CharIn(
//                 min = 65,
//                 bitSet = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57},
//                 ranges = NonEmptyList(
//                   head = (&#39;A&#39;, &#39;Z&#39;),
//                   tail = List((&#39;a&#39;, &#39;z&#39;))
//                 )
//               ),
//               min = 1,
//               maxMinusOne = 2147483647,
//               acc1 = cats.parse.Accumulator0$$anon$11@403f9dc5
//             )
//           ),
//           second = Void(
//             parser = CharIn(
//               min = 58,
//               bitSet = {0},
//               ranges = NonEmptyList(head = (&#39;:&#39;, &#39;:&#39;), tail = List())
//             )
//           )
//         ),
//         fn = cats.parse.Parser0$$Lambda$13126/1895385475@7f390a19
//       ),
//       second = StringP(
//         parser = Rep(
//           p1 = Prod(
//             first = Rep(
//               p1 = CharIn(
//                 min = 65,
//                 bitSet = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57},
//                 ranges = NonEmptyList(
//                   head = (&#39;A&#39;, &#39;Z&#39;),
//                   tail = List((&#39;a&#39;, &#39;z&#39;))
//                 )
//               ),
//               min = 1,
//               maxMinusOne = 2147483647,
//               acc1 = cats.parse.Accumulator0$$anon$11@403f9dc5
// ...
</span><span>
</span><span class="keyword">val</span><span> </span><span class="identifier">p3</span><span> = (</span><span class="identifier">searchWord</span><span> ~ </span><span class="identifier">sp</span><span>.?).</span><span class="identifier">rep</span><span>.</span><span class="identifier">string</span><span>
</span><span class="comment">// p3: Parser[String] = StringP(
//   parser = Rep(
//     p1 = Prod(
//       first = Rep(
//         p1 = CharIn(
//           min = 65,
//           bitSet = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57},
//           ranges = NonEmptyList(head = (&#39;A&#39;, &#39;Z&#39;), tail = List((&#39;a&#39;, &#39;z&#39;)))
//         ),
//         min = 1,
//         maxMinusOne = 2147483647,
//         acc1 = cats.parse.Accumulator0$$anon$11@403f9dc5
//       ),
//       second = OneOf0(
//         all = List(
//           CharIn(
//             min = 32,
//             bitSet = {0},
//             ranges = NonEmptyList(head = (&#39; &#39;, &#39; &#39;), tail = List())
//           ),
//           Pure(result = ())
//         )
//       )
//     ),
//     min = 1,
//     maxMinusOne = 2147483647,
//     acc1 = cats.parse.Accumulator0$$anon$11@403f9dc5
//   )
// )
</span><span>
(</span><span class="identifier">p2</span><span>.</span><span class="identifier">backtrack</span><span> | </span><span class="identifier">p3</span><span>).</span><span class="identifier">parse</span><span>(</span><span class="string-literal">&quot;title:The Wind Has Risen&quot;</span><span>)
</span><span class="comment">// res44: Either[Parser.Error, (String, Object with Serializable)] = Right(
//   value = (&quot;&quot;, (Some(value = (&quot;title&quot;, ())), &quot;The Wind Has Risen&quot;))
// )
// res0 = Right((,(Some((title,())),The Wind Has Risen)))
</span><span>(</span><span class="identifier">p2</span><span>.</span><span class="identifier">backtrack</span><span> | </span><span class="identifier">p3</span><span>).</span><span class="identifier">parse</span><span>(</span><span class="string-literal">&quot;The Wind Has Risen&quot;</span><span>)
</span><span class="comment">// res45: Either[Parser.Error, (String, Object with Serializable)] = Right(
//   value = (&quot;&quot;, &quot;The Wind Has Risen&quot;)
// )</span></code></pre>
        <p>But this problem might be resolved with <code>soft</code> method inside the first parser since the right side of it actually returns an epsilon failure itself:</p>
        <pre><code class="nohighlight"><span class="keyword">val</span><span> </span><span class="identifier">fieldValueSoft</span><span> = </span><span class="identifier">alpha</span><span>.</span><span class="identifier">rep</span><span>.</span><span class="identifier">string</span><span>.</span><span class="identifier">soft</span><span> ~ </span><span class="identifier">pchar</span><span>(</span><span class="char-literal">&#39;:&#39;</span><span>)
</span><span class="comment">// fieldValueSoft: Parser[(String, Unit)] = SoftProd(
//   first = StringP(
//     parser = Rep(
//       p1 = CharIn(
//         min = 65,
//         bitSet = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57},
//         ranges = NonEmptyList(head = (&#39;A&#39;, &#39;Z&#39;), tail = List((&#39;a&#39;, &#39;z&#39;)))
//       ),
//       min = 1,
//       maxMinusOne = 2147483647,
//       acc1 = cats.parse.Accumulator0$$anon$11@403f9dc5
//     )
//   ),
//   second = Void(
//     parser = CharIn(
//       min = 58,
//       bitSet = {0},
//       ranges = NonEmptyList(head = (&#39;:&#39;, &#39;:&#39;), tail = List())
//     )
//   )
// )
</span><span>
</span><span class="keyword">val</span><span> </span><span class="identifier">p4</span><span> = </span><span class="identifier">fieldValueSoft</span><span>.? ~ (</span><span class="identifier">searchWord</span><span> ~ </span><span class="identifier">sp</span><span>.?).</span><span class="identifier">rep</span><span>.</span><span class="identifier">string</span><span>
</span><span class="comment">// p4: cats.parse.Parser0[(Option[(String, Unit)], String)] = OneOf(
//   all = List(
//     Prod(
//       first = Map(
//         parser = SoftProd(
//           first = StringP(
//             parser = Rep(
//               p1 = CharIn(
//                 min = 65,
//                 bitSet = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57},
//                 ranges = NonEmptyList(
//                   head = (&#39;A&#39;, &#39;Z&#39;),
//                   tail = List((&#39;a&#39;, &#39;z&#39;))
//                 )
//               ),
//               min = 1,
//               maxMinusOne = 2147483647,
//               acc1 = cats.parse.Accumulator0$$anon$11@403f9dc5
//             )
//           ),
//           second = Void(
//             parser = CharIn(
//               min = 58,
//               bitSet = {0},
//               ranges = NonEmptyList(head = (&#39;:&#39;, &#39;:&#39;), tail = List())
//             )
//           )
//         ),
//         fn = cats.parse.Parser0$$Lambda$13126/1895385475@7f390a19
//       ),
//       second = StringP(
//         parser = Rep(
//           p1 = Prod(
//             first = Rep(
//               p1 = CharIn(
//                 min = 65,
//                 bitSet = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57},
//                 ranges = NonEmptyList(
//                   head = (&#39;A&#39;, &#39;Z&#39;),
//                   tail = List((&#39;a&#39;, &#39;z&#39;))
//                 )
//               ),
//               min = 1,
//               maxMinusOne = 2147483647,
//               acc1 = cats.parse.Accumulator0$$anon$11@403f9dc5
// ...
</span><span>
</span><span class="identifier">p4</span><span>.</span><span class="identifier">parse</span><span>(</span><span class="string-literal">&quot;title:The Wind Has Risen&quot;</span><span>)
</span><span class="comment">// res46: Either[Parser.Error, (String, (Option[(String, Unit)], String))] = Right(
//   value = (&quot;&quot;, (Some(value = (&quot;title&quot;, ())), &quot;The Wind Has Risen&quot;))
// )
// res2 = Right((,(Some((title,())),The Wind Has Risen)))
</span><span class="identifier">p4</span><span>.</span><span class="identifier">parse</span><span>(</span><span class="string-literal">&quot;The Wind Has Risen&quot;</span><span>)
</span><span class="comment">// res47: Either[Parser.Error, (String, (Option[(String, Unit)], String))] = Right(
//   value = (&quot;&quot;, (None, &quot;The Wind Has Risen&quot;))
// )</span></code></pre>
        <p>So when the <em>right side</em> returns an epsilon failure the <code>soft</code> method allows us to rewind parsed input and try to proceed it&#39;s parsing with next parsers (without changing the parser itself!).</p>
        
        <h1 id="json-parser-example" class="section">JSON parser example<a class="anchor-link right" href="#json-parser-example"><i class="icofont-laika">&#xef71;</i></a></h1>
        <p>Below is most of a json parser (the string unescaping is elided). This example can give you a feel
        for what it is like to use this library.</p>
        <pre><code class="nohighlight"><span class="keyword">import</span><span> </span><span class="identifier">cats</span><span>.</span><span class="identifier">parse</span><span>.{</span><span class="type-name">Parser0</span><span>, </span><span class="type-name">Parser</span><span> =&gt; </span><span class="type-name">P</span><span>, </span><span class="type-name">Numbers</span><span>}
</span><span class="keyword">import</span><span> </span><span class="identifier">org</span><span>.</span><span class="identifier">typelevel</span><span>.</span><span class="identifier">jawn</span><span>.</span><span class="identifier">ast</span><span>.</span><span class="identifier">_</span><span>

</span><span class="keyword">object</span><span> </span><span class="type-name">Json</span><span> {
  </span><span class="keyword">private</span><span>[</span><span class="keyword">this</span><span>] </span><span class="keyword">val</span><span> </span><span class="identifier">whitespace</span><span>: </span><span class="type-name">P</span><span>[</span><span class="type-name">Unit</span><span>] = </span><span class="type-name">P</span><span>.</span><span class="identifier">charIn</span><span>(</span><span class="string-literal">&quot; </span><span class="escape-sequence">\t\r\n</span><span class="string-literal">&quot;</span><span>).</span><span class="identifier">void</span><span>
  </span><span class="keyword">private</span><span>[</span><span class="keyword">this</span><span>] </span><span class="keyword">val</span><span> </span><span class="identifier">whitespaces0</span><span>: </span><span class="type-name">Parser0</span><span>[</span><span class="type-name">Unit</span><span>] = </span><span class="identifier">whitespace</span><span>.</span><span class="identifier">rep0</span><span>.</span><span class="identifier">void</span><span>

  </span><span class="keyword">val</span><span> </span><span class="identifier">parser</span><span>: </span><span class="type-name">P</span><span>[</span><span class="type-name">JValue</span><span>] = </span><span class="type-name">P</span><span>.</span><span class="identifier">recursive</span><span>[</span><span class="type-name">JValue</span><span>] { </span><span class="identifier">recurse</span><span> =&gt;
    </span><span class="keyword">val</span><span> </span><span class="identifier">pnull</span><span> = </span><span class="type-name">P</span><span>.</span><span class="identifier">string</span><span>(</span><span class="string-literal">&quot;null&quot;</span><span>).</span><span class="identifier">as</span><span>(</span><span class="type-name">JNull</span><span>)
    </span><span class="keyword">val</span><span> </span><span class="identifier">bool</span><span> = </span><span class="type-name">P</span><span>.</span><span class="identifier">string</span><span>(</span><span class="string-literal">&quot;true&quot;</span><span>).</span><span class="identifier">as</span><span>(</span><span class="type-name">JBool</span><span>.</span><span class="type-name">True</span><span>).</span><span class="identifier">orElse</span><span>(</span><span class="type-name">P</span><span>.</span><span class="identifier">string</span><span>(</span><span class="string-literal">&quot;false&quot;</span><span>).</span><span class="identifier">as</span><span>(</span><span class="type-name">JBool</span><span>.</span><span class="type-name">False</span><span>))
    </span><span class="keyword">val</span><span> </span><span class="identifier">justStr</span><span> = </span><span class="type-name">JsonStringUtil</span><span>.</span><span class="identifier">escapedString</span><span>(</span><span class="char-literal">&#39;&quot;&#39;</span><span>)
    </span><span class="keyword">val</span><span> </span><span class="identifier">str</span><span> = </span><span class="identifier">justStr</span><span>.</span><span class="identifier">map</span><span>(</span><span class="type-name">JString</span><span>(</span><span class="identifier">_</span><span>))
    </span><span class="keyword">val</span><span> </span><span class="identifier">num</span><span> = </span><span class="type-name">Numbers</span><span>.</span><span class="identifier">jsonNumber</span><span>.</span><span class="identifier">map</span><span>(</span><span class="type-name">JNum</span><span>(</span><span class="identifier">_</span><span>))

    </span><span class="keyword">val</span><span> </span><span class="identifier">listSep</span><span>: </span><span class="type-name">P</span><span>[</span><span class="type-name">Unit</span><span>] =
      </span><span class="type-name">P</span><span>.</span><span class="identifier">char</span><span>(</span><span class="char-literal">&#39;,&#39;</span><span>).</span><span class="identifier">soft</span><span>.</span><span class="identifier">surroundedBy</span><span>(</span><span class="identifier">whitespaces0</span><span>).</span><span class="identifier">void</span><span>

    </span><span class="keyword">def</span><span> </span><span class="declaration-name">rep</span><span>[</span><span class="type-name">A</span><span>](</span><span class="identifier">pa</span><span>: </span><span class="type-name">P</span><span>[</span><span class="type-name">A</span><span>]): </span><span class="type-name">Parser0</span><span>[</span><span class="type-name">List</span><span>[</span><span class="type-name">A</span><span>]] =
      </span><span class="identifier">pa</span><span>.</span><span class="identifier">repSep0</span><span>(</span><span class="identifier">listSep</span><span>).</span><span class="identifier">surroundedBy</span><span>(</span><span class="identifier">whitespaces0</span><span>)

    </span><span class="keyword">val</span><span> </span><span class="identifier">list</span><span> = </span><span class="identifier">rep</span><span>(</span><span class="identifier">recurse</span><span>).</span><span class="identifier">with1</span><span>
      .</span><span class="identifier">between</span><span>(</span><span class="type-name">P</span><span>.</span><span class="identifier">char</span><span>(</span><span class="char-literal">&#39;[&#39;</span><span>), </span><span class="type-name">P</span><span>.</span><span class="identifier">char</span><span>(</span><span class="char-literal">&#39;]&#39;</span><span>))
      .</span><span class="identifier">map</span><span> { </span><span class="identifier">vs</span><span> =&gt; </span><span class="type-name">JArray</span><span>.</span><span class="identifier">fromSeq</span><span>(</span><span class="identifier">vs</span><span>) }

    </span><span class="keyword">val</span><span> </span><span class="identifier">kv</span><span>: </span><span class="type-name">P</span><span>[(</span><span class="type-name">String</span><span>, </span><span class="type-name">JValue</span><span>)] =
      </span><span class="identifier">justStr</span><span> ~ (</span><span class="type-name">P</span><span>.</span><span class="identifier">char</span><span>(</span><span class="char-literal">&#39;:&#39;</span><span>).</span><span class="identifier">surroundedBy</span><span>(</span><span class="identifier">whitespaces0</span><span>) *&gt; </span><span class="identifier">recurse</span><span>)

    </span><span class="keyword">val</span><span> </span><span class="identifier">obj</span><span> = </span><span class="identifier">rep</span><span>(</span><span class="identifier">kv</span><span>).</span><span class="identifier">with1</span><span>
      .</span><span class="identifier">between</span><span>(</span><span class="type-name">P</span><span>.</span><span class="identifier">char</span><span>(</span><span class="char-literal">&#39;{&#39;</span><span>), </span><span class="type-name">P</span><span>.</span><span class="identifier">char</span><span>(</span><span class="char-literal">&#39;}&#39;</span><span>))
      .</span><span class="identifier">map</span><span> { </span><span class="identifier">vs</span><span> =&gt; </span><span class="type-name">JObject</span><span>.</span><span class="identifier">fromSeq</span><span>(</span><span class="identifier">vs</span><span>) }

    </span><span class="type-name">P</span><span>.</span><span class="identifier">oneOf</span><span>(</span><span class="identifier">str</span><span> :: </span><span class="identifier">num</span><span> :: </span><span class="identifier">list</span><span> :: </span><span class="identifier">obj</span><span> :: </span><span class="identifier">bool</span><span> :: </span><span class="identifier">pnull</span><span> :: </span><span class="type-name">Nil</span><span>)
  }

  </span><span class="comment">// any whitespace followed by json followed by whitespace followed by end
</span><span>  </span><span class="keyword">val</span><span> </span><span class="identifier">parserFile</span><span>: </span><span class="type-name">P</span><span>[</span><span class="type-name">JValue</span><span>] = </span><span class="identifier">whitespaces0</span><span>.</span><span class="identifier">with1</span><span> *&gt; </span><span class="identifier">parser</span><span> &lt;* (</span><span class="identifier">whitespaces0</span><span> ~ </span><span class="type-name">P</span><span>.</span><span class="identifier">end</span><span>)
}</span></code></pre>
        
        <h1 id="performance" class="section">Performance<a class="anchor-link right" href="#performance"><i class="icofont-laika">&#xef71;</i></a></h1>
        <p>We have a benchmark suite that compares JSON parsing across several commonly used libraries. A
        recent (2021/11/05) result is below:</p>
        <pre><code>[info] Benchmark                         Mode  Cnt    Score    Error  Units
[info] BarBench.catsParseParse           avgt    4    10           ms/op
[info] BarBench.fastparseParse           avgt    4    10           ms/op
[info] BarBench.jawnParse                avgt    4    10           ms/op
[info] BarBench.parboiled2Parse          avgt    4    10           ms/op
[info] BarBench.parsleyParseCold         avgt    4    0.064   0.001  ms/op
[info] Bla25Bench.catsParseParse         avgt    4   23.095   0.174  ms/op
[info] Bla25Bench.fastparseParse         avgt    4   15.622   0.414  ms/op
[info] Bla25Bench.jawnParse              avgt    4    7.501   0.143  ms/op
[info] Bla25Bench.parboiled2Parse        avgt    4   18.423   6.094  ms/op
[info] Bla25Bench.parsleyParseCold       avgt    4   30.752   0.279  ms/op
[info] CountriesBench.catsParseParse     avgt    4    7.169   0.041  ms/op
[info] CountriesBench.fastparseParse     avgt    4    5.023   0.023  ms/op
[info] CountriesBench.jawnParse          avgt    4    1.235   0.011  ms/op
[info] CountriesBench.parboiled2Parse    avgt    4    2.936   0.008  ms/op
[info] CountriesBench.parsleyParseCold   avgt    4   11.800   0.162  ms/op
[info] Qux2Bench.catsParseParse          avgt    4    7.031   0.599  ms/op
[info] Qux2Bench.fastparseParse          avgt    4    6.597   0.031  ms/op
[info] Qux2Bench.jawnParse               avgt    4    2.227   0.014  ms/op
[info] Qux2Bench.parboiled2Parse         avgt    4    5.514   0.472  ms/op
[info] Qux2Bench.parsleyParseCold        avgt    4   10.327   0.293  ms/op
[info] StringInBenchmarks.oneOfParse     avgt    4   88.105   2.658  ns/op
[info] StringInBenchmarks.stringInParse  avgt    4  129.246   1.820  ns/op
[info] Ugh10kBench.catsParseParse        avgt    4   53.679   1.385  ms/op
[info] Ugh10kBench.fastparseParse        avgt    4   45.165   0.356  ms/op
[info] Ugh10kBench.jawnParse             avgt    4   11.404   0.068  ms/op
[info] Ugh10kBench.parboiled2Parse       avgt    4   31.984   0.748  ms/op
[info] Ugh10kBench.parsleyParseCold      avgt    4   77.150   1.093  ms/op</code></pre>
        <p>Note that parboiled and fastparse both use macros that make them very difficult to port to Dotty.
        Jawn is a specialized and optimized JSON parser, so that can be considered an upper bound on
        performance.
        Keep in mind that parser performance depends both on the parsing library but also how the parser
        is written, but these results suggest that this library is already quite competitive.</p>
        
        <h1 id="migrating-from-fastparse" class="section">Migrating from Fastparse<a class="anchor-link right" href="#migrating-from-fastparse"><i class="icofont-laika">&#xef71;</i></a></h1>
        <p>You should find all the Fastparse methods you are used to. If not, feel free to open an issue.
        There are a few things to keep in mind:</p>
        <ol class="arabic">
          <li>In fastparse, you wrap a parser in <code>P(...)</code> to make the interior lazy. Following cats, to get a lazily constructed parser use <code>Parser.defer</code> or <code>cats.Defer[Parser].defer</code>.</li>
          <li>In fastparse the <code>~</code> operator does tuple concatenation. This can be nice, but also complex to see what the resulting type is. In cats-parse, <code>~</code> always returns a Tuple2 containing the parsed values from the left and right. To recover fastparse-like behavior, use cats syntax <code>(pa, pb, pc...).tupled</code>.</li>
          <li>In fastparse, backtracking is opt-out by using cuts. In cats-parse, backtracking is opt-in using <code>.backtrack</code>. Put another way, normal product operations in cats-parse are like <code>~/</code> in fastparse.</li>
          <li>In cats-parse, using <code>*&gt;</code>, <code>&lt;*</code>, and <code>.void</code> methods can be a significant optimization: if you don&#39;t need a result, communicate that to the library with those methods.</li>
        </ol>
        
        <h1 id="getting-and-giving-help" class="section">Getting and Giving Help<a class="anchor-link right" href="#getting-and-giving-help"><i class="icofont-laika">&#xef71;</i></a></h1>
        <p>We welcome new contributors and new maintainers. Please feel free to open issues and PRs. If you have any
        problem using the library, an issue is the best way to ask a question until we flush out more
        documentation.</p>

        <hr style="margin-top: 30px"/>
        <footer style="font-size: 90%; text-align: center">
          cats-parse is a <a href="https://typelevel.org/">Typelevel</a> project distributed under the <a href="https://opensource.org/licenses/MIT">MIT</a> license.
        </footer>

      </main>

    </div>

  </body>
</html>
